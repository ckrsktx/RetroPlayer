<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Retro Player</title>
<link rel="manifest" href="manifest.json">
<style>
  :root{ --accent:#fff; --bg:#000; --fg:#fff }
  *{ box-sizing:border-box; margin:0; padding:0; -webkit-tap-highlight-color:transparent; user-select:none }
  html,body{ height:100%; overflow:hidden; background:var(--bg); color:var(--fg); font-family:system-ui; display:flex; flex-direction:column; align-items:center; text-align:center }
  #top{ flex:0 0 auto; height:env(safe-area-inset-top) }
  #wrap{ flex:1; width:100%; overflow:auto; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:0 1rem 1rem }
  #capaWrap{ position:relative; width:min(45vw,9rem); aspect-ratio:1; overflow:hidden; box-shadow:0 0 1.2rem var(--accent); margin-bottom:1rem }
  #capa{ width:100%; height:100%; object-fit:cover }
  #disco{ position:absolute; inset:0; background:#111; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity .3s }
  #disco svg{ width:50%; height:50%; stroke:#444; stroke-width:1; fill:none }
  #bar{ display:flex; gap:.8rem; margin-bottom:.8rem; align-items:center }
  .btn{ width:2.4rem; height:2.4rem; background:rgba(255,255,255,.08); border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer }
  .btn svg{ width:1.1rem; height:1.1rem; stroke:var(--fg); stroke-width:1.5; fill:none }
  .btn.on{ background:var(--accent); color:var(--bg) }
  #info{ margin-bottom:.6rem }
  #tit{ font-size:1.1rem; font-weight:600; letter-spacing:.5px; margin-bottom:.1rem }
  #art{ opacity:.7; font-size:.85rem; font-style:italic }
  #bubbles{ display:flex; gap:.4rem; flex-wrap:wrap; justify-content:center; margin-bottom:1rem; max-width:90vw }
  .bubble{ padding:.25rem .6rem; border:1px solid var(--accent); border-radius:2rem; font-size:.7rem; cursor:pointer; transition:background .2s; white-space:nowrap }
  .bubble.on{ background:var(--accent); color:var(--bg) }
  #roleta{ width:100%; max-height:35vh; overflow:auto; list-style:none; scrollbar-width:none }
  #roleta::-webkit-scrollbar{ display:none }
  li{ display:flex; flex-direction:column; padding:.3rem 0; cursor:pointer; gap:.1rem; background:rgba(255,255,255,.03); border-radius:.25rem; margin-bottom:.15rem }
  li.on{ color:#ff00ff !important; font-weight:600 }
  footer{ width:100%; padding:.4rem 0; font-size:.55rem; opacity:.4; letter-spacing:1px }

  /* caixa flutuante de playlists */
  #pickBox{ position:fixed; inset:0; background:rgba(0,0,0,.7); display:none; align-items:center; justify-content:center; z-index:10 }
  #pickBox.on{ display:flex }
  #pickContent{ background:#111; border:1px solid var(--accent); border-radius:1rem; padding:1rem; max-width:90vw; max-height:70vh; overflow:auto; display:flex; flex-wrap:wrap; gap:.4rem; justify-content:center }
  #pickContent .bubble{ margin:0 }

  /* botão atualizar */
  #atualizar{ margin:1rem 0 .5rem; padding:.5rem 1rem; border:1px solid var(--accent); background:transparent; color:var(--accent); border-radius:2rem; font-size:.8rem; cursor:pointer }
</style>
</head>
<body>

<div id="top"></div>

<div id="wrap">

  <div id="capaWrap">
    <img id="capa" src="https://i.ibb.co/VW1Hn4MF/Screenshot-2025-09-23-10-00-03-283-com-miui-gallery-edit.jpg"/>
    <div id="disco">
      <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="#444" stroke-width="1" fill="none"/><circle cx="12" cy="12" r="3" stroke="#444" stroke-width="1" fill="none"/></svg>
    </div>
  </div>

  <div id="bar">
    <div class="btn" id="prev"><svg viewBox="0 0 24 24"><path d="M19 20L9 12l10-8v16zM5 4v16"/></svg></div>
    <div class="btn" id="playBtn"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></div>
    <div class="btn" id="next"><svg viewBox="0 0 24 24"><path d="M5 4l10 8-10 8V4zm14 0v16"/></svg></div>
    <div class="btn" id="shufBtn"><svg viewBox="0 0 24 24"><path d="M16 3h5v5M4 20L21 3m0 13v5h-5M4 4l5 5"/></svg></div>
  </div>

  <div id="info">
    <div id="tit">–</div>
    <div id="art">–</div>
  </div>

  <!-- escolha de playlist -->
  <div id="pickBox"><div id="pickContent"></div></div>
  <div id="bubbles"><span class="bubble" id="pickTrigger">escolha a playlist</span></div>

  <ul id="roleta"></ul>

  <!-- BOTÃO ATUALIZAR -->
  <button id="atualizar">Atualizar Playlist</button>

</div>

<footer>RETRO PLAYER</footer>

<audio id="a" preload="metadata"></audio>

<script>
/* ---------- CONFIG ---------- */
const API_KEY = '685a04193652e98c9e5e598dc6d306ab';
/* ---------- SUBSTITUA O BLOCO CONST PLAYLISTS ---------- */
let PLAYLISTS = {}; // será preenchido

async function loadPlaylistsMeta() {
  const metaUrl = 'https://raw.githubusercontent.com/ckrsktx/RetroPlayer/main/playlists.json?t=' + Date.now();
  const res = await fetch(metaUrl);
  PLAYLISTS = await res.json();
}

/* ---------- ATUALIZAR PLAYLIST (nova versão) ---------- */
$('#atualizar').onclick = async () => {
  // 1) atualiza o objeto PLAYLISTS
  await loadPlaylistsMeta();
  // 2) limpa caches
  if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
    await caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k))));
    navigator.serviceWorker.controller.postMessage({cmd:'SKIP_WAITING'});
  }
  // 3) recarrega a playlist ativa
  const busted = PLAYLISTS[currentPl] + '?t=' + Date.now();
  try {
    const res = await fetch(busted);
    q = await res.json();
    played = []; idx = 0;
    renderRoleta(); loadTrack();
  } catch (e) {
    alert('Erro ao buscar nova versão.');
  }
};

/* ---------------------------- */
const $ = s => document.querySelector(s);
const a = $('#a'), capa = $('#capa'), disco = $('#disco'), tit = $('#tit'), art = $('#art'), playBtn = $('#playBtn'), prev = $('#prev'), next = $('#next'), shufBtn = $('#shufBtn'), roleta = $('#roleta'), bubbles = $('#bubbles'), pickBox = $('#pickBox'), pickContent = $('#pickContent'), pickTrigger = $('#pickTrigger');
let q = [], idx = 0, shuf = false, currentPl = 'Alternative';

/* ---------- CORES DA CAPA ---------- */
function setAccent(color) {
  document.documentElement.style.setProperty('--accent', color);
}
function getPalette(img) {
  const cv = document.createElement('canvas'), ctx = cv.getContext('2d');
  cv.width = img.naturalWidth; cv.height = img.naturalHeight;
  ctx.drawImage(img, 0, 0);
  const d = ctx.getImageData(0, 0, cv.width, cv.height).data, rgb = [0, 0, 0], n = d.length / 4;
  for (let i = 0; i < d.length; i += 4) { rgb[0] += d[i]; rgb[1] += d[i + 1]; rgb[2] += d[i + 2]; }
  rgb.forEach((v, i) => rgb[i] = Math.round(v / n));
  return `rgb(${rgb.join(',')})`;
}
/* ---------- CAPA + COR ---------- */
async function loadTrack() {
  const t = q[idx];
  a.src = t.url;
  tit.textContent = t.title;
  art.textContent = t.artist;
  document.title = `${t.title} – ${t.artist} | Retro Player`;
  
  try {
    const url = `https://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${API_KEY}&artist=${encodeURIComponent(t.artist)}&track=${encodeURIComponent(t.title)}&format=json`;
    const res = await fetch(url);
    const data = await res.json();
    const img = data?.track?.album?.image?.find(x => x.size === 'extralarge')?.['#text'];
    
    if (img && img.trim() !== '') {
      capa.src = img;
      disco.style.opacity = 0;
      capa.onload = () => setAccent(getPalette(capa));
    } else {
      capa.src = "https://i.ibb.co/VW1Hn4MF/Screenshot-2025-09-23-10-00-03-283-com-miui-gallery-edit.jpg";
      disco.style.opacity = 0;
      setAccent("#00ffff");
    }
  } catch {
    capa.src = "https://i.ibb.co/VW1Hn4MF/Screenshot-2025-09-23-10-00-03-283-com-miui-gallery-edit.jpg";
    disco.style.opacity = 0;
    setAccent("#00ffff");
  }

  centerTrack();
  markOnly();
  updateSession();
}
/* ---------- PLAY/PAUSE + SINCRONISMO ---------- */
function play() { a.play(); }
function pause() { a.pause(); }
function togglePlay() {
  a.paused ? play() : pause();
}
playBtn.onclick = togglePlay;
a.onplay = a.onpause = updateIcon;
function updateIcon() {
  playBtn.innerHTML = a.paused
    ? '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'
    : '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
}

/* ---------- CONTROLES ---------- */
prev.onclick = () => skip(-1);
next.onclick = () => skip(1);
shufBtn.onclick = () => {
  shuf = !shuf;
  shufBtn.classList.toggle('on', shuf);
  loadPl();
};
function skip(d) {
  idx = (idx + d + q.length) % q.length;
  loadTrack();
  play();
}

/* ---------- CENTRA FAIXA NA PLAYLIST ---------- */
function centerTrack() {
  const li = roleta.children[idx];
  if (li) li.scrollIntoView({ block: 'center', behavior: 'smooth' });
}

/* ---------- MARCA SÓ QUEM TOCA ---------- */
function markOnly() {
  document.querySelectorAll('li').forEach((li, i) => li.classList.toggle('on', i === idx));
}

/* ---------- MEDIA SESSION ---------- */
let mediaSession = navigator.mediaSession;
function updateSession() {
  const t = q[idx];
  if (!t) return;
  mediaSession.metadata = new MediaMetadata({
    title: t.title,
    artist: t.artist,
    artwork: [{ src: capa.src || 'https://i.ibb.co/VW1Hn4MF/Screenshot-2025-09-23-10-00-03-283-com-miui-gallery-edit.jpg', sizes: '512x512', type: 'image/jpeg' }]
  });
  mediaSession.setActionHandler('play', play);
  mediaSession.setActionHandler('pause', pause);
  mediaSession.setActionHandler('previoustrack', () => skip(-1));
  mediaSession.setActionHandler('nexttrack', () => skip(1));
}

/* ---------- BOLHAS + CAIXA FLUTUANTE ---------- */
function buildPickBox() {
  pickContent.innerHTML = '';
  Object.keys(PLAYLISTS).forEach(pl => {
    const b = document.createElement('span');
    b.className = 'bubble';
    b.textContent = pl;
    b.onclick = () => {
      document.querySelectorAll('.bubble').forEach(x => x.classList.remove('on'));
      b.classList.add('on');
      currentPl = pl;
      loadPl();
      pickBox.classList.remove('on');
    };
    if (pl === currentPl) b.classList.add('on');
    pickContent.append(b);
  });
}
pickTrigger.onclick = () => { buildPickBox(); pickBox.classList.add('on'); };
pickBox.onclick = (e) => { if (e.target === pickBox) pickBox.classList.remove('on'); };

/* ---------- SHUFFLE ---------- */
let played = [];
function shufflePool() {
  const pool = q.map((_, i) => i).filter(i => !played.includes(i));
  if (!pool.length) played = [];
  const pick = pool[Math.floor(Math.random() * pool.length)];
  played.push(pick);
  return pick;
}

/* ---------- LOAD PLAYLIST ---------- */
async function loadPl() {
  q = await (await fetch(PLAYLISTS[currentPl])).json();
  played = [];
  if (shuf) idx = shufflePool();
  else idx = 0;
  renderRoleta();
  loadTrack();
  a.pause();
  updateIcon();
  pickTrigger.textContent = `Playlist - ${currentPl}`;
}

/* ---------- ROLETA ---------- */
function renderRoleta() {
  roleta.innerHTML = '';
  q.forEach((t, i) => {
    const li = document.createElement('li');
    li.innerHTML = `<span class="mus" style="color:#00ffff;font-size:1rem">${t.title}</span><span class="art" style="font-size:.8rem;font-style:italic">${t.artist}</span>`;
    li.onclick = () => { idx = i; loadTrack(); play(); };
    roleta.append(li);
  });
  markOnly();
  centerTrack();
}

/* ---------- AUTO-PRÓXIMO ---------- */
a.onended = () => {
  if (shuf) idx = shufflePool();
  else idx = (idx + 1) % q.length;
  loadTrack();
  play();
};

/* ---------- ATUALIZAR PLAYLIST ---------- */
$('#atualizar').onclick = async () => {
  // limpa todos os caches
  if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
    await caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k))));
    navigator.serviceWorker.controller.postMessage({cmd:'SKIP_WAITING'});
  }
  // reload sem cache
  location.reload(true);
};
/* ---------- START ---------- */
(async () => {
  await loadPlaylistsMeta(); // <-- carrega URLs atualizadas
  loadPl();
})();
loadPl();

/* ---------- REGISTRA SERVICE WORKER ---------- */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}
</script>
</body>
</html>
